// This Pine Script™ source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © XAUUSD Smart Money Concepts Trading Strategy
// Raja Banks / Wicksdontlie Style Implementation
// Version 4.0 - Fixed Entry Logic

//@version=6
strategy("XAUUSD SMC Strategy v4",
     overlay = true,
     pyramiding = 0,
     initial_capital = 100000,
     default_qty_type = strategy.percent_of_equity,
     default_qty_value = 100,
     commission_type = strategy.commission.cash_per_order,
     commission_value = 0,
     slippage = 2,
     process_orders_on_close = true,
     calc_on_every_tick = false,
     max_boxes_count = 500,
     max_lines_count = 500,
     max_labels_count = 500)

// ============================================================================
// SECTION 1: INPUT PARAMETERS
// ============================================================================

// --- Strategy Settings ---
i_riskPercent         = input.float(1.0, "Risk Per Trade (%)", minval = 0.1, maxval = 5.0, step = 0.1, group = "Strategy Settings")
i_useFixedLots        = input.bool(false, "Use Fixed Lot Size", group = "Strategy Settings")
i_fixedLots           = input.float(0.1, "Fixed Lot Size", minval = 0.01, maxval = 50.0, step = 0.01, group = "Strategy Settings")
i_pipValue            = input.float(1.0, "Pip Value per Lot ($)", group = "Strategy Settings")
i_pipDecimal          = input.int(2, "Pip Decimal Places", minval = 0, maxval = 5, group = "Strategy Settings")

// --- Entry Mode ---
i_entryMode           = input.string("Standard", "Entry Mode", options = ["Aggressive", "Standard", "Conservative"], group = "Entry Settings")
i_requireBOSCHoCH     = input.bool(false, "Require BOS/CHoCH for Entry", group = "Entry Settings")
i_requireOB           = input.bool(true, "Require Order Block", group = "Entry Settings")
i_requireFVG          = input.bool(false, "Require FVG", group = "Entry Settings")
i_requireSweep        = input.bool(false, "Require Liquidity Sweep", group = "Entry Settings")
i_requireHTF          = input.bool(true, "Require HTF Bias Alignment", group = "Entry Settings")

// --- Risk Management ---
i_tpMode              = input.string("Fixed RR", "Take Profit Mode", options = ["Fixed RR", "Structure", "ATR Multiple"], group = "Risk Management")
i_tp1RR               = input.float(1.5, "TP1 Risk:Reward", minval = 0.5, maxval = 5.0, step = 0.1, group = "Risk Management")
i_tp2RR               = input.float(3.0, "TP2 Risk:Reward", minval = 1.0, maxval = 10.0, step = 0.1, group = "Risk Management")
i_tp1ClosePercent     = input.float(50, "TP1 Close %", minval = 25, maxval = 75, group = "Risk Management")
i_slMode              = input.string("Structure", "Stop Loss Mode", options = ["Structure", "ATR", "Fixed Pips"], group = "Risk Management")
i_slATRMult           = input.float(1.5, "SL ATR Multiplier", minval = 0.5, maxval = 5.0, step = 0.1, group = "Risk Management")
i_slFixedPips         = input.float(150, "SL Fixed Pips", minval = 50, maxval = 500, group = "Risk Management")
i_slBuffer            = input.float(20, "SL Buffer (pips)", minval = 0, maxval = 100, group = "Risk Management")
i_useTrailingSL       = input.bool(true, "Enable Trailing Stop", group = "Risk Management")
i_beAfterTP1          = input.bool(true, "Move to BE after TP1", group = "Risk Management")

// --- Structure Settings ---
i_swingLength         = input.int(5, "Swing Detection Length", minval = 2, maxval = 20, group = "Structure Settings")
i_atrLength           = input.int(14, "ATR Period", minval = 5, maxval = 50, group = "Structure Settings")
i_structureLookback   = input.int(50, "Structure Lookback Bars", minval = 20, maxval = 200, group = "Structure Settings")

// --- HTF Settings ---
i_htfTimeframe        = input.timeframe("240", "HTF Timeframe", group = "HTF Settings")

// --- Order Block Settings ---
i_obLookback          = input.int(20, "OB Lookback Bars", minval = 5, maxval = 50, group = "Order Block Settings")
i_obMitigationType    = input.string("Wick", "OB Mitigation Type", options = ["Wick", "Close", "50%"], group = "Order Block Settings")
i_obProximity         = input.float(0.5, "OB Proximity (ATR mult)", minval = 0.1, maxval = 2.0, step = 0.1, group = "Order Block Settings")

// --- FVG Settings ---
i_fvgMinSize          = input.float(0.2, "FVG Min Size (ATR mult)", minval = 0.1, maxval = 1.0, step = 0.1, group = "FVG Settings")

// --- Session Filter ---
i_useSessionFilter    = input.bool(false, "Enable Session Filter", group = "Session Filter")
i_sessionStart        = input.int(2, "Session Start (EST)", minval = 0, maxval = 23, group = "Session Filter")
i_sessionEnd          = input.int(16, "Session End (EST)", minval = 0, maxval = 23, group = "Session Filter")

// --- Day Filter ---
i_useDayFilter        = input.bool(false, "Enable Day Filter", group = "Day Filter")
i_tradeMonday         = input.bool(true, "Trade Monday", group = "Day Filter")
i_tradeTuesday        = input.bool(true, "Trade Tuesday", group = "Day Filter")
i_tradeWednesday      = input.bool(true, "Trade Wednesday", group = "Day Filter")
i_tradeThursday       = input.bool(true, "Trade Thursday", group = "Day Filter")
i_tradeFriday         = input.bool(true, "Trade Friday", group = "Day Filter")

// --- Exposure Management ---
i_maxDailyTrades      = input.int(10, "Max Trades Per Day", minval = 1, maxval = 50, group = "Exposure")
i_maxDailyLosses      = input.int(3, "Max Losses Per Day", minval = 1, maxval = 10, group = "Exposure")
i_cooldownBars        = input.int(3, "Cooldown After Loss (bars)", minval = 0, maxval = 20, group = "Exposure")

// --- Visual Settings ---
i_showOB              = input.bool(true, "Show Order Blocks", group = "Visuals")
i_showFVG             = input.bool(true, "Show FVGs", group = "Visuals")
i_showStructure       = input.bool(true, "Show Structure", group = "Visuals")
i_showSignals         = input.bool(true, "Show Entry Signals", group = "Visuals")
i_showTable           = input.bool(true, "Show Info Table", group = "Visuals")

// --- AI/Alerts ---
i_enableAlerts        = input.bool(true, "Enable Alerts", group = "Alerts")
i_alertPrefix         = input.string("XAUUSD", "Alert Prefix", group = "Alerts")

// ============================================================================
// SECTION 2: CORE CALCULATIONS
// ============================================================================

// --- ATR ---
atr = ta.atr(i_atrLength)

// --- Pip Conversion ---
pipMult = math.pow(10, i_pipDecimal)
priceToPips(float price) => math.abs(price) * pipMult
pipsToPrice(float pips) => pips / pipMult

// --- Position Sizing ---
calcLotSize(float slPips) =>
    if i_useFixedLots
        i_fixedLots
    else
        risk = strategy.equity * (i_riskPercent / 100)
        lots = slPips > 0 ? risk / (slPips * i_pipValue) : 0.01
        math.max(0.01, math.min(50.0, math.round(lots * 100) / 100))

// ============================================================================
// SECTION 3: STRUCTURE ANALYSIS
// ============================================================================

// --- Swing Detection ---
swingHigh = ta.pivothigh(high, i_swingLength, i_swingLength)
swingLow = ta.pivotlow(low, i_swingLength, i_swingLength)

// --- Track Swings ---
var float lastHH = na
var float lastLL = na
var float lastLH = na
var float lastHL = na
var int lastHHBar = na
var int lastLLBar = na
var int lastLHBar = na
var int lastHLBar = na

// Update swing tracking
var float currentSwingHigh = na
var float currentSwingLow = na
var int currentSwingHighBar = na
var int currentSwingLowBar = na

if not na(swingHigh)
    if na(currentSwingHigh) or swingHigh > currentSwingHigh
        // Higher High
        lastHH := swingHigh
        lastHHBar := bar_index - i_swingLength
    else
        // Lower High
        lastLH := swingHigh
        lastLHBar := bar_index - i_swingLength
    currentSwingHigh := swingHigh
    currentSwingHighBar := bar_index - i_swingLength

if not na(swingLow)
    if na(currentSwingLow) or swingLow < currentSwingLow
        // Lower Low
        lastLL := swingLow
        lastLLBar := bar_index - i_swingLength
    else
        // Higher Low
        lastHL := swingLow
        lastHLBar := bar_index - i_swingLength
    currentSwingLow := swingLow
    currentSwingLowBar := bar_index - i_swingLength

// --- Current Structure Bias ---
// Simple: compare recent swing positions
var int bias = 0  // 1 = bullish, -1 = bearish, 0 = neutral

recentSwingHigh = ta.highest(high, i_structureLookback)
recentSwingLow = ta.lowest(low, i_structureLookback)
midPoint = (recentSwingHigh + recentSwingLow) / 2

if close > midPoint and close > ta.sma(close, 20)
    bias := 1
else if close < midPoint and close < ta.sma(close, 20)
    bias := -1
else
    bias := 0

// --- BOS Detection (persists for multiple bars) ---
var int lastBullishBOSBar = na
var int lastBearishBOSBar = na
var float bullishBOSLevel = na
var float bearishBOSLevel = na

// Bullish BOS: Close above recent swing high
if not na(currentSwingHigh) and close > currentSwingHigh and close[1] <= currentSwingHigh
    lastBullishBOSBar := bar_index
    bullishBOSLevel := currentSwingHigh

// Bearish BOS: Close below recent swing low
if not na(currentSwingLow) and close < currentSwingLow and close[1] >= currentSwingLow
    lastBearishBOSBar := bar_index
    bearishBOSLevel := currentSwingLow

// Check if BOS is recent (within lookback period)
recentBullishBOS = not na(lastBullishBOSBar) and (bar_index - lastBullishBOSBar) <= i_structureLookback
recentBearishBOS = not na(lastBearishBOSBar) and (bar_index - lastBearishBOSBar) <= i_structureLookback

// ============================================================================
// SECTION 4: HTF BIAS
// ============================================================================

[htfHigh, htfLow, htfClose] = request.security(syminfo.tickerid, i_htfTimeframe, [high, low, close], lookahead = barmerge.lookahead_off)

htfSwingHigh = request.security(syminfo.tickerid, i_htfTimeframe, ta.highest(high, 20), lookahead = barmerge.lookahead_off)
htfSwingLow = request.security(syminfo.tickerid, i_htfTimeframe, ta.lowest(low, 20), lookahead = barmerge.lookahead_off)
htfMid = (htfSwingHigh + htfSwingLow) / 2
htfMA = request.security(syminfo.tickerid, i_htfTimeframe, ta.sma(close, 20), lookahead = barmerge.lookahead_off)

var int htfBias = 0
if htfClose > htfMid and htfClose > htfMA
    htfBias := 1
else if htfClose < htfMid and htfClose < htfMA
    htfBias := -1
else
    htfBias := 0

// ============================================================================
// SECTION 5: ORDER BLOCK DETECTION (Simplified)
// ============================================================================

type OB
    float top
    float bottom
    bool isBullish
    int barIdx
    bool valid

var array<OB> bullishOBs = array.new<OB>()
var array<OB> bearishOBs = array.new<OB>()

// Detect Order Blocks
// Bullish OB: Last down candle before up move
bullishOBDetected = close > open and close[1] < open[1] and close > high[1]
if bullishOBDetected
    newOB = OB.new(
         top = high[1],
         bottom = low[1],
         isBullish = true,
         barIdx = bar_index - 1,
         valid = true
    )
    array.push(bullishOBs, newOB)
    if array.size(bullishOBs) > 10
        array.shift(bullishOBs)

// Bearish OB: Last up candle before down move
bearishOBDetected = close < open and close[1] > open[1] and close < low[1]
if bearishOBDetected
    newOB = OB.new(
         top = high[1],
         bottom = low[1],
         isBullish = false,
         barIdx = bar_index - 1,
         valid = true
    )
    array.push(bearishOBs, newOB)
    if array.size(bearishOBs) > 10
        array.shift(bearishOBs)

// Check if price is at/near a bullish OB
priceAtBullishOB() =>
    result = false
    obTop = float(na)
    obBottom = float(na)

    if array.size(bullishOBs) > 0
        for i = array.size(bullishOBs) - 1 to 0
            ob = array.get(bullishOBs, i)
            age = bar_index - ob.barIdx
            if ob.valid and age <= i_obLookback
                // Price touching or near the OB
                proximity = atr * i_obProximity
                if low <= ob.top + proximity and close >= ob.bottom - proximity
                    result := true
                    obTop := ob.top
                    obBottom := ob.bottom
                    break
    [result, obTop, obBottom]

// Check if price is at/near a bearish OB
priceAtBearishOB() =>
    result = false
    obTop = float(na)
    obBottom = float(na)

    if array.size(bearishOBs) > 0
        for i = array.size(bearishOBs) - 1 to 0
            ob = array.get(bearishOBs, i)
            age = bar_index - ob.barIdx
            if ob.valid and age <= i_obLookback
                proximity = atr * i_obProximity
                if high >= ob.bottom - proximity and close <= ob.top + proximity
                    result := true
                    obTop := ob.top
                    obBottom := ob.bottom
                    break
    [result, obTop, obBottom]

[atBullishOB, bullOBTop, bullOBBottom] = priceAtBullishOB()
[atBearishOB, bearOBTop, bearOBBottom] = priceAtBearishOB()

// Invalidate OBs when mitigated
if array.size(bullishOBs) > 0
    for i = array.size(bullishOBs) - 1 to 0
        ob = array.get(bullishOBs, i)
        mitigated = switch i_obMitigationType
            "Wick" => low < ob.bottom
            "Close" => close < ob.bottom
            "50%" => close < (ob.top + ob.bottom) / 2
            => low < ob.bottom
        if mitigated
            ob.valid := false

if array.size(bearishOBs) > 0
    for i = array.size(bearishOBs) - 1 to 0
        ob = array.get(bearishOBs, i)
        mitigated = switch i_obMitigationType
            "Wick" => high > ob.top
            "Close" => close > ob.top
            "50%" => close > (ob.top + ob.bottom) / 2
            => high > ob.top
        if mitigated
            ob.valid := false

// ============================================================================
// SECTION 6: FVG DETECTION (Simplified)
// ============================================================================

// Bullish FVG: Gap up
bullishFVG = low > high[2] and (low - high[2]) >= atr * i_fvgMinSize
bullishFVGTop = bullishFVG ? low : na
bullishFVGBottom = bullishFVG ? high[2] : na

// Bearish FVG: Gap down
bearishFVG = high < low[2] and (low[2] - high) >= atr * i_fvgMinSize
bearishFVGTop = bearishFVG ? low[2] : na
bearishFVGBottom = bearishFVG ? high : na

// Track recent FVGs
var float recentBullFVGTop = na
var float recentBullFVGBottom = na
var int recentBullFVGBar = na
var float recentBearFVGTop = na
var float recentBearFVGBottom = na
var int recentBearFVGBar = na

if bullishFVG
    recentBullFVGTop := bullishFVGTop
    recentBullFVGBottom := bullishFVGBottom
    recentBullFVGBar := bar_index

if bearishFVG
    recentBearFVGTop := bearishFVGTop
    recentBearFVGBottom := bearishFVGBottom
    recentBearFVGBar := bar_index

// Check if price is in FVG
priceInBullishFVG = not na(recentBullFVGBar) and (bar_index - recentBullFVGBar) <= i_structureLookback and low <= recentBullFVGTop and high >= recentBullFVGBottom

priceInBearishFVG = not na(recentBearFVGBar) and (bar_index - recentBearFVGBar) <= i_structureLookback and high >= recentBearFVGBottom and low <= recentBearFVGTop

// ============================================================================
// SECTION 7: LIQUIDITY SWEEP DETECTION
// ============================================================================

// Simple liquidity sweep: Wick beyond recent high/low with close back inside
recentHigh = ta.highest(high[1], 20)
recentLow = ta.lowest(low[1], 20)

// Bullish sweep: Wick below recent low, close above
bullishSweep = low < recentLow and close > recentLow and close > open
var int lastBullishSweepBar = na
if bullishSweep
    lastBullishSweepBar := bar_index

// Bearish sweep: Wick above recent high, close below
bearishSweep = high > recentHigh and close < recentHigh and close < open
var int lastBearishSweepBar = na
if bearishSweep
    lastBearishSweepBar := bar_index

recentBullishSweep = not na(lastBullishSweepBar) and (bar_index - lastBullishSweepBar) <= 10
recentBearishSweep = not na(lastBearishSweepBar) and (bar_index - lastBearishSweepBar) <= 10

// ============================================================================
// SECTION 8: FILTERS
// ============================================================================

// Session Filter
currentHour = hour(time, "America/New_York")
inSession = not i_useSessionFilter or (currentHour >= i_sessionStart and currentHour < i_sessionEnd)

// Day Filter
currentDay = dayofweek(time)
validDay = not i_useDayFilter or (
     (currentDay == dayofweek.monday and i_tradeMonday) or
     (currentDay == dayofweek.tuesday and i_tradeTuesday) or
     (currentDay == dayofweek.wednesday and i_tradeWednesday) or
     (currentDay == dayofweek.thursday and i_tradeThursday) or
     (currentDay == dayofweek.friday and i_tradeFriday)
)

// Exposure Management
var int dailyTrades = 0
var int dailyLosses = 0
var int lastLossBar = 0

newDay = ta.change(dayofweek) != 0
if newDay
    dailyTrades := 0
    dailyLosses := 0

canTradeExposure = dailyTrades < i_maxDailyTrades and dailyLosses < i_maxDailyLosses
notInCooldown = bar_index >= lastLossBar + i_cooldownBars

// Combined filter
filtersPass = inSession and validDay and canTradeExposure and notInCooldown

// ============================================================================
// SECTION 9: ENTRY CONDITIONS
// ============================================================================

inLong = strategy.position_size > 0
inShort = strategy.position_size < 0
inPosition = inLong or inShort

// --- Build Entry Conditions Based on Mode ---
// Each component that CAN contribute to entry
hasHTFAlignment_Long = htfBias >= 0  // HTF bullish or neutral
hasHTFAlignment_Short = htfBias <= 0  // HTF bearish or neutral

hasStructure_Long = bias >= 0 or recentBullishBOS
hasStructure_Short = bias <= 0 or recentBearishBOS

hasOB_Long = atBullishOB
hasOB_Short = atBearishOB

hasFVG_Long = priceInBullishFVG
hasFVG_Short = priceInBearishFVG

hasSweep_Long = recentBullishSweep
hasSweep_Short = recentBearishSweep

// --- Entry Signal Logic ---
// Long: At bullish OB with proper structure
longEntry = filtersPass and not inPosition and
             hasStructure_Long and
             (not i_requireHTF or hasHTFAlignment_Long) and
             (not i_requireOB or hasOB_Long) and
             (not i_requireFVG or hasFVG_Long) and
             (not i_requireSweep or hasSweep_Long) and
             (not i_requireBOSCHoCH or recentBullishBOS)

// Short: At bearish OB with proper structure
shortEntry = filtersPass and not inPosition and
              hasStructure_Short and
              (not i_requireHTF or hasHTFAlignment_Short) and
              (not i_requireOB or hasOB_Short) and
              (not i_requireFVG or hasFVG_Short) and
              (not i_requireSweep or hasSweep_Short) and
              (not i_requireBOSCHoCH or recentBearishBOS)

// Additional confirmation for quality
// Bullish confirmation candle
bullishCandle = close > open and close > (high + low) / 2
bearishCandle = close < open and close < (high + low) / 2

// Apply confirmation based on mode
longSignal = switch i_entryMode
    "Aggressive" => longEntry
    "Standard" => longEntry and bullishCandle
    "Conservative" => longEntry and bullishCandle and recentBullishBOS
    => longEntry

shortSignal = switch i_entryMode
    "Aggressive" => shortEntry
    "Standard" => shortEntry and bearishCandle
    "Conservative" => shortEntry and bearishCandle and recentBearishBOS
    => shortEntry

// ============================================================================
// SECTION 10: STOP LOSS & TAKE PROFIT
// ============================================================================

var float entryPrice = na
var float stopLoss = na
var float takeProfit1 = na
var float takeProfit2 = na

calcStopLoss(bool isLong) =>
    sl = float(na)

    if i_slMode == "Structure"
        if isLong
            // Below recent swing low or OB bottom
            structureSL = not na(currentSwingLow) ? currentSwingLow - pipsToPrice(i_slBuffer) : low - atr * 1.5
            obSL = atBullishOB and not na(bullOBBottom) ? bullOBBottom - pipsToPrice(i_slBuffer) : structureSL
            sl := math.min(structureSL, obSL)
        else
            structureSL = not na(currentSwingHigh) ? currentSwingHigh + pipsToPrice(i_slBuffer) : high + atr * 1.5
            obSL = atBearishOB and not na(bearOBTop) ? bearOBTop + pipsToPrice(i_slBuffer) : structureSL
            sl := math.max(structureSL, obSL)
    else if i_slMode == "ATR"
        sl := isLong ? close - atr * i_slATRMult : close + atr * i_slATRMult
    else  // Fixed Pips
        sl := isLong ? close - pipsToPrice(i_slFixedPips) : close + pipsToPrice(i_slFixedPips)

    sl

calcTakeProfit(bool isLong, float entry, float sl) =>
    slDist = math.abs(entry - sl)
    tp1 = isLong ? entry + slDist * i_tp1RR : entry - slDist * i_tp1RR
    tp2 = isLong ? entry + slDist * i_tp2RR : entry - slDist * i_tp2RR
    [tp1, tp2]

// ============================================================================
// SECTION 11: STRATEGY EXECUTION
// ============================================================================

if longSignal
    entryPrice := close
    stopLoss := calcStopLoss(true)
    [tp1, tp2] = calcTakeProfit(true, close, stopLoss)
    takeProfit1 := tp1
    takeProfit2 := tp2

    slPips = priceToPips(close - stopLoss)
    lots = calcLotSize(slPips)

    strategy.entry("Long", strategy.long)
    strategy.exit("Long TP1", "Long", qty_percent = i_tp1ClosePercent, limit = takeProfit1, stop = stopLoss)
    strategy.exit("Long TP2", "Long", limit = takeProfit2, stop = stopLoss)

    dailyTrades += 1

    if i_enableAlerts
        alert(i_alertPrefix + " LONG Entry @ " + str.tostring(close), alert.freq_once_per_bar)

if shortSignal
    entryPrice := close
    stopLoss := calcStopLoss(false)
    [tp1, tp2] = calcTakeProfit(false, close, stopLoss)
    takeProfit1 := tp1
    takeProfit2 := tp2

    slPips = priceToPips(stopLoss - close)
    lots = calcLotSize(slPips)

    strategy.entry("Short", strategy.short)
    strategy.exit("Short TP1", "Short", qty_percent = i_tp1ClosePercent, limit = takeProfit1, stop = stopLoss)
    strategy.exit("Short TP2", "Short", limit = takeProfit2, stop = stopLoss)

    dailyTrades += 1

    if i_enableAlerts
        alert(i_alertPrefix + " SHORT Entry @ " + str.tostring(close), alert.freq_once_per_bar)

// Track losses
if not inPosition and inPosition[1]
    if strategy.closedtrades > 0
        lastProfit = strategy.closedtrades.profit(strategy.closedtrades - 1)
        if lastProfit < 0
            dailyLosses += 1
            lastLossBar := bar_index

// ============================================================================
// SECTION 12: TRAILING STOP (after TP1)
// ============================================================================

var bool tp1Hit = false
var float trailingSL = na

if inLong
    if strategy.position_size < strategy.position_size[1] and strategy.position_size > 0
        tp1Hit := true
        if i_beAfterTP1
            trailingSL := entryPrice + pipsToPrice(5)

    if tp1Hit and i_useTrailingSL
        newTrailSL = low[1] - atr * 0.3
        if na(trailingSL) or newTrailSL > trailingSL
            trailingSL := newTrailSL
            strategy.exit("Long Trail", "Long", stop = trailingSL)

if inShort
    if strategy.position_size > strategy.position_size[1] and strategy.position_size < 0
        tp1Hit := true
        if i_beAfterTP1
            trailingSL := entryPrice - pipsToPrice(5)

    if tp1Hit and i_useTrailingSL
        newTrailSL = high[1] + atr * 0.3
        if na(trailingSL) or newTrailSL < trailingSL
            trailingSL := newTrailSL
            strategy.exit("Short Trail", "Short", stop = trailingSL)

// Reset on position close
if not inPosition and inPosition[1]
    tp1Hit := false
    trailingSL := na

// ============================================================================
// SECTION 13: VISUALS
// ============================================================================

// Plot signals
plotshape(i_showSignals and longSignal, title = "Long", style = shape.triangleup, location = location.belowbar, color = color.green, size = size.normal)
plotshape(i_showSignals and shortSignal, title = "Short", style = shape.triangledown, location = location.abovebar, color = color.red, size = size.normal)

// Plot structure
plotshape(i_showStructure and not na(swingHigh), title = "Swing High", style = shape.circle, location = location.abovebar, color = color.new(color.red, 50), size = size.tiny, offset = -i_swingLength)
plotshape(i_showStructure and not na(swingLow), title = "Swing Low", style = shape.circle, location = location.belowbar, color = color.new(color.green, 50), size = size.tiny, offset = -i_swingLength)

// Bias background
bgColor = bias == 1 ? color.new(color.green, 95) : bias == -1 ? color.new(color.red, 95) : na
bgcolor(bgColor, title = "Bias Background")

// Info Table
if i_showTable and barstate.islast
    var table infoTable = table.new(position.top_right, 2, 8, bgcolor = color.new(color.black, 80))

    table.cell(infoTable, 0, 0, "SMC Strategy v4", text_color = color.white, text_size = size.small)
    table.cell(infoTable, 1, 0, syminfo.ticker, text_color = color.yellow, text_size = size.small)

    biasText = bias == 1 ? "BULLISH" : bias == -1 ? "BEARISH" : "NEUTRAL"
    biasColor = bias == 1 ? color.green : bias == -1 ? color.red : color.gray
    table.cell(infoTable, 0, 1, "Bias", text_color = color.white, text_size = size.tiny)
    table.cell(infoTable, 1, 1, biasText, text_color = biasColor, text_size = size.tiny)

    htfText = htfBias == 1 ? "BULLISH" : htfBias == -1 ? "BEARISH" : "NEUTRAL"
    htfColor = htfBias == 1 ? color.green : htfBias == -1 ? color.red : color.gray
    table.cell(infoTable, 0, 2, "HTF Bias", text_color = color.white, text_size = size.tiny)
    table.cell(infoTable, 1, 2, htfText, text_color = htfColor, text_size = size.tiny)

    table.cell(infoTable, 0, 3, "At Bull OB", text_color = color.white, text_size = size.tiny)
    table.cell(infoTable, 1, 3, atBullishOB ? "YES" : "NO", text_color = atBullishOB ? color.green : color.gray, text_size = size.tiny)

    table.cell(infoTable, 0, 4, "At Bear OB", text_color = color.white, text_size = size.tiny)
    table.cell(infoTable, 1, 4, atBearishOB ? "YES" : "NO", text_color = atBearishOB ? color.red : color.gray, text_size = size.tiny)

    table.cell(infoTable, 0, 5, "Recent BOS", text_color = color.white, text_size = size.tiny)
    bosText = recentBullishBOS ? "BULL" : recentBearishBOS ? "BEAR" : "NONE"
    table.cell(infoTable, 1, 5, bosText, text_color = color.white, text_size = size.tiny)

    posText = inLong ? "LONG" : inShort ? "SHORT" : "FLAT"
    posColor = inLong ? color.green : inShort ? color.red : color.gray
    table.cell(infoTable, 0, 6, "Position", text_color = color.white, text_size = size.tiny)
    table.cell(infoTable, 1, 6, posText, text_color = posColor, text_size = size.tiny)

    table.cell(infoTable, 0, 7, "Trades Today", text_color = color.white, text_size = size.tiny)
    table.cell(infoTable, 1, 7, str.tostring(dailyTrades), text_color = color.white, text_size = size.tiny)

// Debug plots
plot(atBullishOB ? 1 : 0, title = "At Bullish OB", display = display.data_window)
plot(atBearishOB ? 1 : 0, title = "At Bearish OB", display = display.data_window)
plot(recentBullishBOS ? 1 : 0, title = "Recent Bull BOS", display = display.data_window)
plot(recentBearishBOS ? 1 : 0, title = "Recent Bear BOS", display = display.data_window)
plot(bias, title = "Bias", display = display.data_window)
plot(htfBias, title = "HTF Bias", display = display.data_window)
plot(filtersPass ? 1 : 0, title = "Filters Pass", display = display.data_window)

// ============================================================================
// END
// ============================================================================
