// This Pine Script™ source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © XAUUSD Smart Money Concepts Trading Strategy
// Raja Banks / Wicksdontlie Style Implementation
// Version 3.0 - Pine Script v6 Strategy with AI Integration

//@version=6
strategy("XAUUSD SMC Trading Strategy v6",
     overlay = true,
     pyramiding = 0,
     initial_capital = 100000,
     default_qty_type = strategy.percent_of_equity,
     default_qty_value = 100,
     commission_type = strategy.commission.cash_per_order,
     commission_value = 0,
     slippage = 2,
     process_orders_on_close = false,
     calc_on_every_tick = false,
     max_boxes_count = 500,
     max_lines_count = 500,
     max_labels_count = 500)

// ============================================================================
// SECTION 1: INPUT PARAMETERS
// ============================================================================

// --- Strategy Settings ---
i_initialCapital      = input.float(100000, "Initial Capital ($)", minval = 100, group = "Strategy Settings")
i_riskPercent         = input.float(1.0, "Risk Per Trade (%)", minval = 0.1, maxval = 5.0, step = 0.1, group = "Strategy Settings")
i_useFixedLots        = input.bool(false, "Use Fixed Lot Size", group = "Strategy Settings")
i_fixedLots           = input.float(0.1, "Fixed Lot Size", minval = 0.01, maxval = 50.0, step = 0.01, group = "Strategy Settings")
i_pipValue            = input.float(1.0, "Pip Value per Standard Lot ($)", tooltip = "For XAUUSD: $1.00 per pip per standard lot", group = "Strategy Settings")
i_pipDecimal          = input.int(2, "Pip Decimal Places", minval = 0, maxval = 5, tooltip = "XAUUSD=2, Forex pairs=4 or 5", group = "Strategy Settings")

// --- Confluence Settings ---
i_minConfluenceScore  = input.int(70, "Minimum Confluence Score", minval = 50, maxval = 100, group = "Confluence Settings")
i_obWeight            = input.int(40, "Order Block Weight", minval = 0, maxval = 50, group = "Confluence Settings")
i_sweepWeight         = input.int(30, "Liquidity Sweep Weight", minval = 0, maxval = 50, group = "Confluence Settings")
i_fvgWeight           = input.int(20, "FVG Weight", minval = 0, maxval = 50, group = "Confluence Settings")
i_mtfWeight           = input.int(10, "MTF Alignment Weight", minval = 0, maxval = 20, group = "Confluence Settings")
i_useConfluenceDecay  = input.bool(true, "Enable Confluence Time Decay", group = "Confluence Settings")
i_decayBars           = input.int(20, "Decay Period (bars)", minval = 5, maxval = 100, group = "Confluence Settings")

// --- Risk Management ---
i_tp1RR               = input.float(1.0, "TP1 Risk:Reward", minval = 0.5, maxval = 3.0, step = 0.1, group = "Risk Management")
i_tp2RR               = input.float(2.0, "TP2 Risk:Reward (final)", minval = 1.0, maxval = 5.0, step = 0.1, group = "Risk Management")
i_tp1ClosePercent     = input.float(50, "TP1 Close Percentage (%)", minval = 25, maxval = 75, group = "Risk Management")
i_beOffset            = input.float(5, "Breakeven Offset (pips)", minval = 0, maxval = 50, group = "Risk Management")
i_useTrailingSL       = input.bool(true, "Enable Trailing Stop", group = "Risk Management")
i_trailBuffer         = input.float(0.3, "Trail Buffer (ATR multiplier)", minval = 0.1, maxval = 1.0, step = 0.1, group = "Risk Management")
i_minSlPips           = input.float(100, "Minimum SL (pips)", minval = 10, maxval = 500, group = "Risk Management")
i_maxSlPips           = input.float(2000, "Maximum SL (pips)", minval = 500, maxval = 5000, group = "Risk Management")

// --- Exposure Management ---
i_maxDailyTrades      = input.int(5, "Max Trades Per Day", minval = 1, maxval = 20, group = "Exposure Management")
i_maxDailyLosses      = input.int(3, "Max Losing Trades Per Day", minval = 1, maxval = 10, group = "Exposure Management")
i_maxDrawdownPercent  = input.float(10, "Max Account Drawdown (%)", minval = 5, maxval = 25, group = "Exposure Management")
i_cooldownBars        = input.int(6, "Cooldown Bars After Loss", minval = 0, maxval = 50, group = "Exposure Management")

// --- Structure Settings ---
i_swingLengthHTF      = input.int(10, "HTF Swing Detection Length", minval = 3, maxval = 50, group = "Structure Settings")
i_swingLengthLTF      = input.int(5, "LTF Swing Detection Length", minval = 2, maxval = 20, group = "Structure Settings")
i_atrLength           = input.int(14, "ATR Period", minval = 5, maxval = 50, group = "Structure Settings")

// --- Timeframe Settings ---
i_htfBias             = input.timeframe("240", "HTF for Bias (4H)", group = "Timeframe Settings")
i_useHTFConfirmation  = input.bool(true, "Require HTF Confirmation", group = "Timeframe Settings")

// --- Order Block Settings ---
i_obMinBodyPercent    = input.float(40, "OB Min Body Size (%)", minval = 20, maxval = 80, group = "Order Block Settings") / 100
i_obMinATR            = input.float(0.5, "OB Min Size (ATR mult)", minval = 0.1, maxval = 2.0, step = 0.1, group = "Order Block Settings")
i_obMaxATR            = input.float(3.0, "OB Max Size (ATR mult)", minval = 1.0, maxval = 5.0, step = 0.1, group = "Order Block Settings")
i_obDisplacement      = input.float(1.5, "OB Displacement (ATR mult)", minval = 0.5, maxval = 3.0, step = 0.1, group = "Order Block Settings")
i_maxOrderBlocks      = input.int(10, "Max Order Blocks to Track", minval = 5, maxval = 20, group = "Order Block Settings")
i_obMaxAge            = input.int(100, "OB Max Age (bars)", minval = 20, maxval = 500, group = "Order Block Settings")

// --- FVG Settings ---
i_fvgMinATR           = input.float(0.3, "FVG Min Size (ATR mult)", minval = 0.1, maxval = 1.0, step = 0.1, group = "FVG Settings")
i_fvgMaxATR           = input.float(2.0, "FVG Max Size (ATR mult)", minval = 0.5, maxval = 5.0, step = 0.1, group = "FVG Settings")
i_maxFVGs             = input.int(15, "Max FVGs to Track", minval = 5, maxval = 30, group = "FVG Settings")
i_fvgMaxAge           = input.int(50, "FVG Max Age (bars)", minval = 10, maxval = 200, group = "FVG Settings")

// --- Liquidity Settings ---
i_equalThreshold      = input.float(0.05, "Equal Highs/Lows Threshold (%)", minval = 0.01, maxval = 0.2, step = 0.01, group = "Liquidity Settings") / 100
i_sweepMinExtension   = input.float(0.1, "Sweep Min Extension (ATR mult)", minval = 0.05, maxval = 0.5, step = 0.05, group = "Liquidity Settings")
i_sweepMaxExtension   = input.float(2.0, "Sweep Max Extension (ATR mult)", minval = 0.5, maxval = 5.0, step = 0.1, group = "Liquidity Settings")
i_sweepMaxAge         = input.int(10, "Sweep Max Age (bars)", minval = 1, maxval = 30, group = "Liquidity Settings")

// --- Session Filter Settings ---
i_useSessions         = input.bool(true, "Enable Session Filter", group = "Session Filter")
i_londonStart         = input.int(2, "London Start (EST hour)", minval = 0, maxval = 23, group = "Session Filter")
i_londonEnd           = input.int(5, "London End (EST hour)", minval = 0, maxval = 23, group = "Session Filter")
i_nyStart             = input.int(7, "NY Start (EST hour)", minval = 0, maxval = 23, group = "Session Filter")
i_nyEnd               = input.int(10, "NY End (EST hour)", minval = 0, maxval = 23, group = "Session Filter")
i_avoidMonday         = input.bool(true, "Avoid Monday Trading", group = "Session Filter")
i_avoidFriday         = input.bool(true, "Avoid Friday Trading", group = "Session Filter")

// --- Volatility Filter Settings ---
i_useVolatilityFilter = input.bool(true, "Enable Volatility Filter", group = "Volatility Filter")
i_minATRRatio         = input.float(0.5, "Min ATR Ratio (vs 50-period avg)", minval = 0.1, maxval = 1.0, step = 0.1, group = "Volatility Filter")
i_maxATRRatio         = input.float(2.5, "Max ATR Ratio (vs 50-period avg)", minval = 1.5, maxval = 5.0, step = 0.1, group = "Volatility Filter")

// --- Visual Settings ---
i_showOB              = input.bool(true, "Show Order Blocks", group = "Visual Settings")
i_showFVG             = input.bool(true, "Show Fair Value Gaps", group = "Visual Settings")
i_showLiquidity       = input.bool(true, "Show Liquidity Levels", group = "Visual Settings")
i_showSignals         = input.bool(true, "Show Entry Signals", group = "Visual Settings")
i_showTable           = input.bool(true, "Show Info Table", group = "Visual Settings")
i_showSLTP            = input.bool(true, "Show SL/TP Lines", group = "Visual Settings")

// --- AI Integration Settings ---
i_enableAIAlerts      = input.bool(true, "Enable AI-Ready Alerts", group = "AI Integration")
i_webhookURL          = input.string("", "Webhook URL (optional)", group = "AI Integration")
i_tradeIDPrefix       = input.string("SMC", "Trade ID Prefix", group = "AI Integration")
i_includeContext      = input.bool(true, "Include Market Context in Alerts", group = "AI Integration")

// --- Broker Integration Settings ---
i_enableBrokerAlerts  = input.bool(false, "Enable Broker Alerts", group = "Broker Integration")
i_licenseID           = input.string("", "PineConnector/Broker License ID", group = "Broker Integration")
i_symbol              = input.string("XAUUSD", "Symbol for Alerts", group = "Broker Integration")

// ============================================================================
// SECTION 2: GLOBAL CONSTANTS AND TYPE DEFINITIONS
// ============================================================================

// --- Trade State Constants (v6: using const for compile-time optimization) ---
const int STATE_FLAT          = 0
const int STATE_LONG_ENTRY    = 1
const int STATE_LONG_TP1      = 2
const int STATE_LONG_TRAILING = 3
const int STATE_SHORT_ENTRY   = 4
const int STATE_SHORT_TP1     = 5
const int STATE_SHORT_TRAILING = 6

// --- Signal Quality Constants ---
const int TIER_NONE  = 0
const int TIER_B     = 1
const int TIER_A     = 2
const int TIER_APLUS = 3

// --- Direction Constants ---
const int DIR_NEUTRAL = 0
const int DIR_LONG    = 1
const int DIR_SHORT   = -1

// --- Order Block Type ---
type OrderBlock
    float top
    float bottom
    float eq
    int   startBar
    bool  isBullish
    bool  isMitigated
    int   mitigationBar
    int   strength
    int   id

// --- FVG Type ---
type FairValueGap
    float top
    float bottom
    float size
    int   formationBar
    bool  isBullish
    bool  isFilled
    float fillPercent
    bool  isInPremium
    int   id

// --- Liquidity Level Type ---
type LiquidityLevel
    float price
    int   touchCount
    int   firstBar
    int   lastBar
    bool  isBuyside
    bool  isSwept

// --- Liquidity Sweep Type ---
type LiquiditySweep
    float level
    int   sweepBar
    bool  isBuyside
    float rejectionStrength

// --- Confluence Score Type ---
type ConfluenceScore
    float  total
    float  obScore
    float  sweepScore
    float  fvgScore
    float  mtfScore
    bool   isValid
    int    tier
    string tierString

// --- Trade Signal Type (for AI integration) ---
type TradeSignal
    string id
    int    direction
    float  entry
    float  sl
    float  tp1
    float  tp2
    float  lotSize
    float  riskAmount
    float  slPips
    int    confluenceScore
    int    tier
    string reason
    int    timestamp

// --- Arrays for tracking ---
var array<OrderBlock>     orderBlocks     = array.new<OrderBlock>()
var array<FairValueGap>   fvgList         = array.new<FairValueGap>()
var array<LiquidityLevel> liquidityLevels = array.new<LiquidityLevel>()

// --- Global ID counters ---
var int obIDCounter    = 0
var int fvgIDCounter   = 0
var int tradeIDCounter = 0

// --- Visual object arrays for cleanup (v6: proper memory management) ---
var array<box>  obBoxes   = array.new<box>()
var array<box>  fvgBoxes  = array.new<box>()
var array<line> liqLines  = array.new<line>()
var array<line> slTPLines = array.new<line>()

// ============================================================================
// SECTION 3: UTILITY FUNCTIONS
// ============================================================================

// --- ATR Calculation ---
atr    = ta.atr(i_atrLength)
atrSMA = ta.sma(atr, 50)
atrRatio = atrSMA > 0 ? atr / atrSMA : 1.0

// --- Pip Conversion Functions (flexible for any symbol) ---
pipMultiplier = math.pow(10, i_pipDecimal)

priceToPips(float priceDistance) =>
    math.abs(priceDistance) * pipMultiplier

pipsToPrice(float pips) =>
    pips / pipMultiplier

// --- Position Sizing Function ---
calculateLotSize(float slPips, float accountEquity) =>
    if slPips <= 0
        0.01
    else if i_useFixedLots
        i_fixedLots
    else
        riskAmount = accountEquity * (i_riskPercent / 100)
        rawLots    = riskAmount / (slPips * i_pipValue)
        math.max(0.01, math.min(50.0, math.round(rawLots * 100) / 100))

// --- Time Functions ---
getHourEST() =>
    hour(time, "America/New_York")

getDayOfWeek() =>
    dayofweek(time)

// --- Generate Trade ID ---
generateTradeID() =>
    tradeIDCounter += 1
    i_tradeIDPrefix + "_" + str.tostring(year) + str.tostring(month, "00") + str.tostring(dayofmonth, "00") + "_" + str.tostring(tradeIDCounter, "0000")

// --- Time Decay Multiplier ---
getDecayMultiplier(int barsAgo) =>
    if not i_useConfluenceDecay
        1.0
    else
        decay = 1.0 - (float(barsAgo) / float(i_decayBars))
        math.max(0.0, math.min(1.0, decay))

// --- Clear Visual Arrays (v6: using negative indexing for efficient cleanup) ---
clearVisualArrays() =>
    // Clear OB boxes from end to start using negative indexing
    while array.size(obBoxes) > 0
        box.delete(array.get(obBoxes, -1))
        array.pop(obBoxes)
    // Clear FVG boxes
    while array.size(fvgBoxes) > 0
        box.delete(array.get(fvgBoxes, -1))
        array.pop(fvgBoxes)
    // Clear liquidity lines
    while array.size(liqLines) > 0
        line.delete(array.get(liqLines, -1))
        array.pop(liqLines)
    // Clear SL/TP lines
    while array.size(slTPLines) > 0
        line.delete(array.get(slTPLines, -1))
        array.pop(slTPLines)

// --- Safe Float Comparison (v6: handles na properly with short-circuit) ---
safeGreater(float a, float b) =>
    not na(a) and not na(b) and a > b

safeLess(float a, float b) =>
    not na(a) and not na(b) and a < b

safeGreaterOrEqual(float a, float b) =>
    not na(a) and not na(b) and a >= b

safeLessOrEqual(float a, float b) =>
    not na(a) and not na(b) and a <= b

// ============================================================================
// SECTION 4: MARKET STRUCTURE ANALYSIS
// ============================================================================

// --- Swing High/Low Detection ---
swingHighHTF = ta.pivothigh(high, i_swingLengthHTF, i_swingLengthHTF)
swingLowHTF  = ta.pivotlow(low, i_swingLengthHTF, i_swingLengthHTF)
swingHighLTF = ta.pivothigh(high, i_swingLengthLTF, i_swingLengthLTF)
swingLowLTF  = ta.pivotlow(low, i_swingLengthLTF, i_swingLengthLTF)

// --- Track Swing Points ---
var float lastSwingHigh    = na
var float lastSwingLow     = na
var float prevSwingHigh    = na
var float prevSwingLow     = na
var int   lastSwingHighBar = na
var int   lastSwingLowBar  = na

if not na(swingHighHTF)
    prevSwingHigh    := lastSwingHigh
    lastSwingHigh    := swingHighHTF
    lastSwingHighBar := bar_index - i_swingLengthHTF

if not na(swingLowHTF)
    prevSwingLow    := lastSwingLow
    lastSwingLow    := swingLowHTF
    lastSwingLowBar := bar_index - i_swingLengthHTF

// --- Structure Classification (v6: short-circuit evaluation) ---
isHigherHigh = safeGreater(lastSwingHigh, prevSwingHigh)
isLowerHigh  = safeLess(lastSwingHigh, prevSwingHigh)
isHigherLow  = safeGreater(lastSwingLow, prevSwingLow)
isLowerLow   = safeLess(lastSwingLow, prevSwingLow)

// --- Market Structure Bias ---
var int structureBias = DIR_NEUTRAL

isBullishStructure = isHigherHigh and isHigherLow
isBearishStructure = isLowerHigh and isLowerLow

if isBullishStructure
    structureBias := DIR_LONG
else if isBearishStructure
    structureBias := DIR_SHORT

// --- Break of Structure (BOS) Detection ---
var bool  bullishBOS = false
var bool  bearishBOS = false
var float bosLevel   = na
var int   bosBar     = na

// v6: Short-circuit prevents na evaluation issues
bullishBOSCondition = not na(lastSwingHigh) and close > lastSwingHigh and close[1] <= lastSwingHigh
if bullishBOSCondition and structureBias >= DIR_NEUTRAL
    bullishBOS := true
    bosLevel   := lastSwingHigh
    bosBar     := bar_index
else
    bullishBOS := false

bearishBOSCondition = not na(lastSwingLow) and close < lastSwingLow and close[1] >= lastSwingLow
if bearishBOSCondition and structureBias <= DIR_NEUTRAL
    bearishBOS := true
    bosLevel   := lastSwingLow
    bosBar     := bar_index
else
    bearishBOS := false

// --- Change of Character (CHoCH) Detection ---
var bool  bullishCHoCH = false
var bool  bearishCHoCH = false
var float chochLevel   = na
var int   chochBar     = na

bullishCHoCHCondition = not na(lastSwingHigh) and close > lastSwingHigh and close[1] <= lastSwingHigh and structureBias == DIR_SHORT
if bullishCHoCHCondition
    bullishCHoCH := true
    chochLevel   := lastSwingHigh
    chochBar     := bar_index
else
    bullishCHoCH := false

bearishCHoCHCondition = not na(lastSwingLow) and close < lastSwingLow and close[1] >= lastSwingLow and structureBias == DIR_LONG
if bearishCHoCHCondition
    bearishCHoCH := true
    chochLevel   := lastSwingLow
    chochBar     := bar_index
else
    bearishCHoCH := false

// --- Premium/Discount Zone Calculation ---
swingRange  = not na(lastSwingHigh) and not na(lastSwingLow) ? lastSwingHigh - lastSwingLow : 0.0
equilibrium = not na(lastSwingLow) and swingRange > 0 ? lastSwingLow + (swingRange / 2) : close
isPremium   = close > equilibrium
isDiscount  = close < equilibrium

// ============================================================================
// SECTION 5: ORDER BLOCK DETECTION
// ============================================================================

detectOrderBlock() =>
    OrderBlock ob = na

    if bullishBOS or bullishCHoCH
        for i = 1 to 20
            if close[i] < open[i]  // Bearish candle
                bodySize    = math.abs(close[i] - open[i])
                candleRange = high[i] - low[i]

                // v6: Short-circuit evaluation prevents division issues
                if candleRange > 0 and bodySize >= candleRange * i_obMinBodyPercent
                    if candleRange >= atr * i_obMinATR and candleRange <= atr * i_obMaxATR
                        displacement = high - high[i]
                        if displacement >= atr * i_obDisplacement
                            obIDCounter += 1
                            strengthVal = displacement >= atr * 3.0 ? 3 : displacement >= atr * 2.0 ? 2 : 1
                            ob := OrderBlock.new(
                                 top          = high[i],
                                 bottom       = low[i],
                                 eq           = low[i] + (high[i] - low[i]) / 2,
                                 startBar     = bar_index - i,
                                 isBullish    = true,
                                 isMitigated  = false,
                                 mitigationBar = na,
                                 strength     = strengthVal,
                                 id           = obIDCounter
                            )
                            break

    if bearishBOS or bearishCHoCH
        for i = 1 to 20
            if close[i] > open[i]  // Bullish candle
                bodySize    = math.abs(close[i] - open[i])
                candleRange = high[i] - low[i]

                if candleRange > 0 and bodySize >= candleRange * i_obMinBodyPercent
                    if candleRange >= atr * i_obMinATR and candleRange <= atr * i_obMaxATR
                        displacement = low[i] - low
                        if displacement >= atr * i_obDisplacement
                            obIDCounter += 1
                            strengthVal = displacement >= atr * 3.0 ? 3 : displacement >= atr * 2.0 ? 2 : 1
                            ob := OrderBlock.new(
                                 top          = high[i],
                                 bottom       = low[i],
                                 eq           = low[i] + (high[i] - low[i]) / 2,
                                 startBar     = bar_index - i,
                                 isBullish    = false,
                                 isMitigated  = false,
                                 mitigationBar = na,
                                 strength     = strengthVal,
                                 id           = obIDCounter
                            )
                            break
    ob

// --- Add and manage Order Blocks ---
newOB = detectOrderBlock()
if not na(newOB)
    // Check for duplicates before adding
    isDuplicate = false
    if array.size(orderBlocks) > 0
        for i = 0 to array.size(orderBlocks) - 1
            existingOB = array.get(orderBlocks, i)
            if math.abs(existingOB.eq - newOB.eq) < atr * 0.2 and existingOB.isBullish == newOB.isBullish
                isDuplicate := true
                break

    if not isDuplicate
        array.push(orderBlocks, newOB)
        while array.size(orderBlocks) > i_maxOrderBlocks
            array.shift(orderBlocks)

// --- Update Order Block Mitigation and Age ---
if array.size(orderBlocks) > 0
    for i = array.size(orderBlocks) - 1 to 0
        ob = array.get(orderBlocks, i)

        // Remove stale OBs
        obAge = bar_index - ob.startBar
        if obAge > i_obMaxAge
            array.remove(orderBlocks, i)
            continue

        if not ob.isMitigated
            if ob.isBullish
                if low <= ob.eq
                    ob.isMitigated  := true
                    ob.mitigationBar := bar_index
            else
                if high >= ob.eq
                    ob.isMitigated  := true
                    ob.mitigationBar := bar_index

// --- Get Active Order Block ---
getActiveOB(bool isBullish) =>
    OrderBlock result = na
    float bestScore = 0.0

    if array.size(orderBlocks) > 0
        for i = array.size(orderBlocks) - 1 to 0
            ob    = array.get(orderBlocks, i)
            obAge = bar_index - ob.startBar

            // v6: Short-circuit evaluation for multiple conditions
            if ob.isBullish == isBullish and not ob.isMitigated and obAge <= i_obMaxAge
                inZone = isBullish ?
                         (close >= ob.bottom and close <= ob.top * 1.01) :
                         (close <= ob.top and close >= ob.bottom * 0.99)

                if inZone
                    score = float(ob.strength) * getDecayMultiplier(obAge)
                    if score > bestScore
                        bestScore := score
                        result    := ob
    result

// ============================================================================
// SECTION 6: FAIR VALUE GAP DETECTION
// ============================================================================

detectFVG() =>
    FairValueGap fvg = na

    // Bullish FVG
    bullishGap = low - high[2]
    if bullishGap > 0 and bullishGap >= atr * i_fvgMinATR and bullishGap <= atr * i_fvgMaxATR
        if close[1] > open[1]
            fvgIDCounter += 1
            fvg := FairValueGap.new(
                 top         = low,
                 bottom      = high[2],
                 size        = bullishGap,
                 formationBar = bar_index - 1,
                 isBullish   = true,
                 isFilled    = false,
                 fillPercent = 0.0,
                 isInPremium = high[2] > equilibrium,
                 id          = fvgIDCounter
            )

    // Bearish FVG
    bearishGap = low[2] - high
    if bearishGap > 0 and bearishGap >= atr * i_fvgMinATR and bearishGap <= atr * i_fvgMaxATR
        if close[1] < open[1]
            fvgIDCounter += 1
            fvg := FairValueGap.new(
                 top         = low[2],
                 bottom      = high,
                 size        = bearishGap,
                 formationBar = bar_index - 1,
                 isBullish   = false,
                 isFilled    = false,
                 fillPercent = 0.0,
                 isInPremium = low[2] > equilibrium,
                 id          = fvgIDCounter
            )
    fvg

// --- Add and manage FVGs ---
newFVG = detectFVG()
if not na(newFVG)
    // Check for duplicates
    isDuplicate = false
    if array.size(fvgList) > 0
        for i = 0 to array.size(fvgList) - 1
            existingFVG = array.get(fvgList, i)
            if math.abs(existingFVG.top - newFVG.top) < atr * 0.1 and existingFVG.isBullish == newFVG.isBullish
                isDuplicate := true
                break

    if not isDuplicate
        array.push(fvgList, newFVG)
        while array.size(fvgList) > i_maxFVGs
            array.shift(fvgList)

// --- Update FVG Fill Status and Age ---
if array.size(fvgList) > 0
    for i = array.size(fvgList) - 1 to 0
        fvg    = array.get(fvgList, i)
        fvgAge = bar_index - fvg.formationBar

        // Remove stale or filled FVGs
        if fvgAge > i_fvgMaxAge or fvg.isFilled
            array.remove(fvgList, i)
            continue

        if not fvg.isFilled
            if fvg.isBullish
                if low <= fvg.top
                    fillAmount      = math.max(0.0, fvg.top - math.max(low, fvg.bottom))
                    fvg.fillPercent := fvg.size > 0 ? math.min(100.0, (fillAmount / fvg.size) * 100) : 0.0
                    if low <= fvg.bottom
                        fvg.isFilled := true
            else
                if high >= fvg.bottom
                    fillAmount      = math.max(0.0, math.min(high, fvg.top) - fvg.bottom)
                    fvg.fillPercent := fvg.size > 0 ? math.min(100.0, (fillAmount / fvg.size) * 100) : 0.0
                    if high >= fvg.top
                        fvg.isFilled := true

// --- Get Active FVG ---
getActiveFVG(bool isBullish) =>
    FairValueGap result = na
    float bestScore = 0.0

    if array.size(fvgList) > 0
        for i = array.size(fvgList) - 1 to 0
            fvg    = array.get(fvgList, i)
            fvgAge = bar_index - fvg.formationBar

            if fvg.isBullish == isBullish and not fvg.isFilled and fvgAge <= i_fvgMaxAge
                inZone = isBullish ?
                         (close >= fvg.bottom and close <= fvg.top) :
                         (close <= fvg.top and close >= fvg.bottom)

                if inZone
                    score = (fvg.size / atr) * getDecayMultiplier(fvgAge)
                    if score > bestScore
                        bestScore := score
                        result    := fvg
    result

// ============================================================================
// SECTION 7: LIQUIDITY DETECTION
// ============================================================================

addOrUpdateLevel(float price, bool isBuyside) =>
    found     = false
    threshold = price * i_equalThreshold

    if array.size(liquidityLevels) > 0
        for i = 0 to array.size(liquidityLevels) - 1
            level = array.get(liquidityLevels, i)
            if level.isBuyside == isBuyside and math.abs(level.price - price) <= threshold
                level.touchCount := level.touchCount + 1
                level.lastBar    := bar_index
                found := true
                break

    if not found
        newLevel = LiquidityLevel.new(
             price      = price,
             touchCount = 1,
             firstBar   = bar_index,
             lastBar    = bar_index,
             isBuyside  = isBuyside,
             isSwept    = false
        )
        array.push(liquidityLevels, newLevel)
        if array.size(liquidityLevels) > 30
            array.shift(liquidityLevels)

if not na(swingHighHTF)
    addOrUpdateLevel(swingHighHTF, true)
if not na(swingLowHTF)
    addOrUpdateLevel(swingLowHTF, false)

// --- Liquidity Sweep Detection ---
var LiquiditySweep lastSweep = na
var bool sweepDetected = false
var int  sweepBar      = na

detectLiquiditySweep() =>
    LiquiditySweep sweep = na

    if array.size(liquidityLevels) > 0
        for i = array.size(liquidityLevels) - 1 to 0
            level = array.get(liquidityLevels, i)
            if not level.isSwept
                if level.isBuyside  // Buyside liquidity
                    if high > level.price and close < level.price
                        wickAbove = high - level.price
                        // v6: Short-circuit evaluation
                        if wickAbove >= atr * i_sweepMinExtension and wickAbove <= atr * i_sweepMaxExtension
                            bodyReject  = level.price - close
                            rejStrength = wickAbove > 0 ? bodyReject / wickAbove : 0.0
                            if rejStrength > 0.5
                                level.isSwept := true
                                sweep := LiquiditySweep.new(
                                     level             = level.price,
                                     sweepBar          = bar_index,
                                     isBuyside         = true,
                                     rejectionStrength = rejStrength
                                )
                                break
                else  // Sellside liquidity
                    if low < level.price and close > level.price
                        wickBelow = level.price - low
                        if wickBelow >= atr * i_sweepMinExtension and wickBelow <= atr * i_sweepMaxExtension
                            bodyReject  = close - level.price
                            rejStrength = wickBelow > 0 ? bodyReject / wickBelow : 0.0
                            if rejStrength > 0.5
                                level.isSwept := true
                                sweep := LiquiditySweep.new(
                                     level             = level.price,
                                     sweepBar          = bar_index,
                                     isBuyside         = false,
                                     rejectionStrength = rejStrength
                                )
                                break
    sweep

currentSweep = detectLiquiditySweep()
if not na(currentSweep)
    lastSweep      := currentSweep
    sweepDetected  := true
    sweepBar       := bar_index
else
    // Check if sweep is still recent
    if not na(sweepBar) and bar_index - sweepBar > i_sweepMaxAge
        sweepDetected := false

// ============================================================================
// SECTION 8: MULTI-TIMEFRAME ANALYSIS
// ============================================================================

// --- Request HTF Data (v6: Dynamic requests with explicit lookahead) ---
[htfHigh, htfLow, htfClose, htfOpen] = request.security(
     syminfo.tickerid,
     i_htfBias,
     [high, low, close, open],
     lookahead = barmerge.lookahead_off
)

htfSwingHigh = request.security(
     syminfo.tickerid,
     i_htfBias,
     ta.pivothigh(high, i_swingLengthHTF, i_swingLengthHTF),
     lookahead = barmerge.lookahead_off
)

htfSwingLow = request.security(
     syminfo.tickerid,
     i_htfBias,
     ta.pivotlow(low, i_swingLengthHTF, i_swingLengthHTF),
     lookahead = barmerge.lookahead_off
)

// --- HTF Structure ---
var float htfLastSwingHigh = na
var float htfLastSwingLow  = na
var float htfPrevSwingHigh = na
var float htfPrevSwingLow  = na

if not na(htfSwingHigh)
    htfPrevSwingHigh := htfLastSwingHigh
    htfLastSwingHigh := htfSwingHigh

if not na(htfSwingLow)
    htfPrevSwingLow := htfLastSwingLow
    htfLastSwingLow := htfSwingLow

htfHigherHigh = safeGreater(htfLastSwingHigh, htfPrevSwingHigh)
htfHigherLow  = safeGreater(htfLastSwingLow, htfPrevSwingLow)
htfLowerHigh  = safeLess(htfLastSwingHigh, htfPrevSwingHigh)
htfLowerLow   = safeLess(htfLastSwingLow, htfPrevSwingLow)

htfBullishStructure = htfHigherHigh and htfHigherLow
htfBearishStructure = htfLowerHigh and htfLowerLow

var int htfBias = DIR_NEUTRAL
if htfBullishStructure
    htfBias := DIR_LONG
else if htfBearishStructure
    htfBias := DIR_SHORT

// --- MTF Alignment ---
mtfAligned  = (htfBias == DIR_LONG and structureBias == DIR_LONG) or (htfBias == DIR_SHORT and structureBias == DIR_SHORT)
mtfStrength = htfBias == structureBias ? (htfBias != DIR_NEUTRAL ? 2 : 1) : 0

// --- OTE Zone ---
htfRange = not na(htfLastSwingHigh) and not na(htfLastSwingLow) ? htfLastSwingHigh - htfLastSwingLow : 0.0

oteFib62 = htfBias == DIR_LONG ?
           htfLastSwingHigh - (htfRange * 0.62) :
           htfLastSwingLow + (htfRange * 0.62)

oteFib79 = htfBias == DIR_LONG ?
           htfLastSwingHigh - (htfRange * 0.79) :
           htfLastSwingLow + (htfRange * 0.79)

oteZoneTop    = htfBias == DIR_LONG ? oteFib62 : htfLastSwingLow + (htfRange * 0.79)
oteZoneBottom = htfBias == DIR_LONG ? oteFib79 : htfLastSwingLow + (htfRange * 0.62)

inOTEZone = htfRange > 0 and
            close >= math.min(oteZoneTop, oteZoneBottom) and
            close <= math.max(oteZoneTop, oteZoneBottom)

// ============================================================================
// SECTION 9: CONFLUENCE SCORING ENGINE
// ============================================================================

calculateConfluence(bool isBullish) =>
    ConfluenceScore score = ConfluenceScore.new(
         total      = 0.0,
         obScore    = 0.0,
         sweepScore = 0.0,
         fvgScore   = 0.0,
         mtfScore   = 0.0,
         isValid    = false,
         tier       = TIER_NONE,
         tierString = "NO TRADE"
    )

    // --- Order Block Score ---
    activeOB = getActiveOB(isBullish)
    if not na(activeOB)
        obAge    = bar_index - activeOB.startBar
        decayMult = getDecayMultiplier(obAge)

        float obBaseScore = float(i_obWeight) * 0.6

        if activeOB.strength == 3
            obBaseScore *= 1.0
        else if activeOB.strength == 2
            obBaseScore *= 0.7
        else
            obBaseScore *= 0.4

        // S/R confluence bonus
        atSR = false
        if array.size(liquidityLevels) > 0
            for i = 0 to array.size(liquidityLevels) - 1
                level = array.get(liquidityLevels, i)
                if level.touchCount >= 2 and math.abs(level.price - activeOB.eq) <= atr * 0.5
                    atSR := true
                    break

        if atSR
            obBaseScore += float(i_obWeight) * 0.4

        score.obScore := obBaseScore * decayMult

    // --- Liquidity Sweep Score ---
    if sweepDetected and not na(lastSweep)
        sweepAge = bar_index - lastSweep.sweepBar
        if sweepAge <= i_sweepMaxAge
            sweepMatchesDirection = (isBullish and not lastSweep.isBuyside) or (not isBullish and lastSweep.isBuyside)
            if sweepMatchesDirection
                decayMult = getDecayMultiplier(sweepAge)
                float sweepBaseScore = float(i_sweepWeight)

                if lastSweep.rejectionStrength >= 1.0
                    sweepBaseScore *= 1.0
                else if lastSweep.rejectionStrength >= 0.7
                    sweepBaseScore *= 0.7
                else
                    sweepBaseScore *= 0.4

                score.sweepScore := sweepBaseScore * decayMult

    // --- FVG Score ---
    activeFVG = getActiveFVG(isBullish)
    if not na(activeFVG)
        fvgAge    = bar_index - activeFVG.formationBar
        decayMult = getDecayMultiplier(fvgAge)

        float fvgBaseScore = float(i_fvgWeight)
        sizeRatio = activeFVG.size / atr

        if sizeRatio >= 1.0
            fvgBaseScore *= 1.0
        else if sizeRatio >= 0.5
            fvgBaseScore *= 0.7
        else
            fvgBaseScore *= 0.4

        // Premium/Discount alignment bonus
        correctZone = (isBullish and not activeFVG.isInPremium) or (not isBullish and activeFVG.isInPremium)
        if correctZone
            fvgBaseScore *= 1.2

        score.fvgScore := math.min(float(i_fvgWeight), fvgBaseScore * decayMult)

    // --- MTF Alignment Score ---
    if mtfAligned
        score.mtfScore := mtfStrength == 2 ? float(i_mtfWeight) : float(i_mtfWeight) * 0.5

    // --- Calculate Total ---
    score.total   := score.obScore + score.sweepScore + score.fvgScore + score.mtfScore
    score.isValid := score.total >= float(i_minConfluenceScore)

    // --- Tier Assignment ---
    if score.total >= 90
        score.tier       := TIER_APLUS
        score.tierString := "A+"
    else if score.total >= 80
        score.tier       := TIER_A
        score.tierString := "A"
    else if score.total >= 70
        score.tier       := TIER_B
        score.tierString := "B"
    else
        score.tier       := TIER_NONE
        score.tierString := "NO TRADE"

    score

bullishConfluence = calculateConfluence(true)
bearishConfluence = calculateConfluence(false)

// ============================================================================
// SECTION 10: FILTER CONDITIONS
// ============================================================================

// --- Session Filter ---
currentHour       = getHourEST()
inLondonSession   = currentHour >= i_londonStart and currentHour < i_londonEnd
inNYSession       = currentHour >= i_nyStart and currentHour < i_nyEnd
inLondonNYOverlap = currentHour >= 8 and currentHour < 12
inValidSession    = not i_useSessions or inLondonSession or inNYSession or inLondonNYOverlap

// --- Day Filter ---
currentDay = getDayOfWeek()
isMonday   = currentDay == dayofweek.monday
isFriday   = currentDay == dayofweek.friday
validDay   = (not i_avoidMonday or not isMonday) and (not i_avoidFriday or not isFriday)

// --- Volatility Filter ---
validVolatility = not i_useVolatilityFilter or (atrRatio >= i_minATRRatio and atrRatio <= i_maxATRRatio)

// --- Range Detection ---
[diPlus, diMinus, adxValue] = ta.dmi(14, 14)
isRanging  = adxValue < 20
notRanging = not isRanging

// --- Combined Filter ---
allFiltersPassed = inValidSession and validDay and validVolatility and notRanging

// ============================================================================
// SECTION 11: EXPOSURE MANAGEMENT
// ============================================================================

var int   dailyLosses      = 0
var int   dailyTrades      = 0
var int   lastLossBar      = 0
var bool  tradingEnabled   = true
var float peakEquity       = i_initialCapital
var float currentDrawdown  = 0.0

// --- Day Change Detection ---
newDay = ta.change(dayofweek) != 0

if newDay
    dailyLosses    := 0
    dailyTrades    := 0
    tradingEnabled := true

// --- Update Peak Equity and Drawdown ---
currentEquity = strategy.equity
if currentEquity > peakEquity
    peakEquity := currentEquity
currentDrawdown := peakEquity > 0 ? (peakEquity - currentEquity) / peakEquity * 100 : 0.0

// --- Check Limits ---
if currentDrawdown >= i_maxDrawdownPercent
    tradingEnabled := false

if dailyLosses >= i_maxDailyLosses
    tradingEnabled := false

if dailyTrades >= i_maxDailyTrades
    tradingEnabled := false

// --- Cooldown ---
inCooldown = bar_index < lastLossBar + i_cooldownBars

// --- Final Permission ---
canTrade = tradingEnabled and not inCooldown and allFiltersPassed

// ============================================================================
// SECTION 12: SIGNAL GENERATION
// ============================================================================

var string currentTradeID    = ""
var float  signalEntry       = na
var float  signalSL          = na
var float  signalTP1         = na
var float  signalTP2         = na
var float  signalLots        = na
var int    signalTier        = TIER_NONE
var string signalTierString  = ""
var float  signalConfluence  = 0.0

// --- Check if strategy is in position ---
inLongPosition  = strategy.position_size > 0
inShortPosition = strategy.position_size < 0
inPosition      = inLongPosition or inShortPosition

// --- Long Signal Conditions (v6: short-circuit evaluation) ---
longCondition = canTrade and
                not inPosition and
                bullishConfluence.isValid and
                (not i_useHTFConfirmation or htfBias == DIR_LONG) and
                (bullishBOS or bullishCHoCH or (inOTEZone and structureBias == DIR_LONG))

// --- Short Signal Conditions ---
shortCondition = canTrade and
                 not inPosition and
                 bearishConfluence.isValid and
                 (not i_useHTFConfirmation or htfBias == DIR_SHORT) and
                 (bearishBOS or bearishCHoCH or (inOTEZone and structureBias == DIR_SHORT))

// ============================================================================
// SECTION 13: STRATEGY EXECUTION
// ============================================================================

// --- Long Entry ---
if longCondition
    currentTradeID   := generateTradeID()
    signalEntry      := close
    signalTier       := bullishConfluence.tier
    signalTierString := bullishConfluence.tierString
    signalConfluence := bullishConfluence.total

    // Calculate Stop Loss
    activeOB    = getActiveOB(true)
    obSL        = not na(activeOB) ? activeOB.bottom - pipsToPrice(50) : low - atr * 1.5
    structureSL = not na(lastSwingLow) ? lastSwingLow - pipsToPrice(50) : low - atr * 1.5
    sweepSL     = sweepDetected and not na(lastSweep) and not lastSweep.isBuyside ? lastSweep.level - pipsToPrice(30) : low - atr * 1.5
    atrSL       = close - atr * 1.5

    rawSL = math.min(obSL, math.min(structureSL, math.min(sweepSL, atrSL)))
    minSL = close - pipsToPrice(i_minSlPips)
    maxSL = close - pipsToPrice(i_maxSlPips)
    signalSL := math.max(maxSL, math.min(minSL, rawSL))

    // Calculate TPs
    slDistance = close - signalSL
    signalTP1 := close + (slDistance * i_tp1RR)
    signalTP2 := close + (slDistance * i_tp2RR)

    // Calculate Position Size
    slPips     = priceToPips(slDistance)
    signalLots := calculateLotSize(slPips, strategy.equity)

    // Execute Entry
    strategy.entry("Long", strategy.long, comment = currentTradeID)

    // Set Exit Levels
    strategy.exit("Long TP1", "Long",
         qty_percent = i_tp1ClosePercent,
         limit       = signalTP1,
         stop        = signalSL,
         comment     = "TP1")

    strategy.exit("Long TP2", "Long",
         limit   = signalTP2,
         stop    = signalSL,
         comment = "TP2")

    dailyTrades += 1

// --- Short Entry ---
if shortCondition
    currentTradeID   := generateTradeID()
    signalEntry      := close
    signalTier       := bearishConfluence.tier
    signalTierString := bearishConfluence.tierString
    signalConfluence := bearishConfluence.total

    // Calculate Stop Loss
    activeOB    = getActiveOB(false)
    obSL        = not na(activeOB) ? activeOB.top + pipsToPrice(50) : high + atr * 1.5
    structureSL = not na(lastSwingHigh) ? lastSwingHigh + pipsToPrice(50) : high + atr * 1.5
    sweepSL     = sweepDetected and not na(lastSweep) and lastSweep.isBuyside ? lastSweep.level + pipsToPrice(30) : high + atr * 1.5
    atrSL       = close + atr * 1.5

    rawSL = math.max(obSL, math.max(structureSL, math.max(sweepSL, atrSL)))
    minSL = close + pipsToPrice(i_minSlPips)
    maxSL = close + pipsToPrice(i_maxSlPips)
    signalSL := math.min(maxSL, math.max(minSL, rawSL))

    // Calculate TPs
    slDistance = signalSL - close
    signalTP1 := close - (slDistance * i_tp1RR)
    signalTP2 := close - (slDistance * i_tp2RR)

    // Calculate Position Size
    slPips     = priceToPips(slDistance)
    signalLots := calculateLotSize(slPips, strategy.equity)

    // Execute Entry
    strategy.entry("Short", strategy.short, comment = currentTradeID)

    // Set Exit Levels
    strategy.exit("Short TP1", "Short",
         qty_percent = i_tp1ClosePercent,
         limit       = signalTP1,
         stop        = signalSL,
         comment     = "TP1")

    strategy.exit("Short TP2", "Short",
         limit   = signalTP2,
         stop    = signalSL,
         comment = "TP2")

    dailyTrades += 1

// ============================================================================
// SECTION 14: POSITION MANAGEMENT & TRAILING STOP
// ============================================================================

var bool  tp1Hit        = false
var float trailingSL    = na
var float trailSwingLow = na
var float trailSwingHigh = na

// Track LTF swings for trailing
if not na(swingLowLTF)
    trailSwingLow := swingLowLTF
if not na(swingHighLTF)
    trailSwingHigh := swingHighLTF

// --- Long Position Management ---
if inLongPosition and i_useTrailingSL
    // Check if TP1 was hit (position size reduced)
    if strategy.position_size < strategy.position_size[1] and strategy.position_size > 0
        tp1Hit     := true
        trailingSL := signalEntry + pipsToPrice(i_beOffset)

    // Update trailing stop after TP1
    if tp1Hit and not na(trailSwingLow)
        newTrailSL = trailSwingLow - atr * i_trailBuffer
        if na(trailingSL) or (newTrailSL > trailingSL and newTrailSL >= signalEntry)
            trailingSL := newTrailSL
            strategy.exit("Long Trail", "Long", stop = trailingSL, comment = "Trail")

// --- Short Position Management ---
if inShortPosition and i_useTrailingSL
    if strategy.position_size > strategy.position_size[1] and strategy.position_size < 0
        tp1Hit     := true
        trailingSL := signalEntry - pipsToPrice(i_beOffset)

    if tp1Hit and not na(trailSwingHigh)
        newTrailSL = trailSwingHigh + atr * i_trailBuffer
        if na(trailingSL) or (newTrailSL < trailingSL and newTrailSL <= signalEntry)
            trailingSL := newTrailSL
            strategy.exit("Short Trail", "Short", stop = trailingSL, comment = "Trail")

// --- Reset on Position Close ---
if not inPosition and inPosition[1]
    // Check if it was a loss
    lastTradeIndex = strategy.closedtrades - 1
    if lastTradeIndex >= strategy.closedtrades.first_index  // v6: Use first_index for trimmed trades
        if strategy.closedtrades.profit(lastTradeIndex) < 0
            dailyLosses += 1
            lastLossBar := bar_index

    // Reset variables
    tp1Hit        := false
    trailingSL    := na
    currentTradeID := ""

// ============================================================================
// SECTION 15: AI INTEGRATION - ALERT SYSTEM
// ============================================================================

// --- Build JSON Alert for AI Systems (v6: using extended string length) ---
buildAIAlert(string action, string direction, float entry, float sl, float tp1, float tp2, float lots, float confluence, string tier, string tradeID, string reason) =>
    string json = "{"
    json += "\"action\":\"" + action + "\","
    json += "\"trade_id\":\"" + tradeID + "\","
    json += "\"symbol\":\"" + i_symbol + "\","
    json += "\"direction\":\"" + direction + "\","
    json += "\"entry\":" + str.tostring(entry, "#.##") + ","
    json += "\"sl\":" + str.tostring(sl, "#.##") + ","
    json += "\"tp1\":" + str.tostring(tp1, "#.##") + ","
    json += "\"tp2\":" + str.tostring(tp2, "#.##") + ","
    json += "\"lot_size\":" + str.tostring(lots, "#.##") + ","
    json += "\"confluence_score\":" + str.tostring(confluence, "#.#") + ","
    json += "\"tier\":\"" + tier + "\","
    json += "\"reason\":\"" + reason + "\","
    json += "\"timestamp\":" + str.tostring(timenow) + ","

    if i_includeContext
        json += "\"context\":{"
        json += "\"htf_bias\":" + str.tostring(htfBias) + ","
        json += "\"structure_bias\":" + str.tostring(structureBias) + ","
        json += "\"atr\":" + str.tostring(atr, "#.##") + ","
        json += "\"session\":\"" + (inLondonNYOverlap ? "overlap" : inNYSession ? "ny" : inLondonSession ? "london" : "off") + "\","
        json += "\"in_ote\":" + (inOTEZone ? "true" : "false") + ","
        json += "\"is_premium\":" + (isPremium ? "true" : "false") + ","
        json += "\"daily_trades\":" + str.tostring(dailyTrades) + ","
        json += "\"daily_losses\":" + str.tostring(dailyLosses) + ","
        json += "\"drawdown\":" + str.tostring(currentDrawdown, "#.##")
        json += "}"
    else
        json += "\"context\":{}"

    json += "}"
    json

// --- Build Broker Alert (PineConnector format) ---
buildBrokerEntryAlert(bool isLong, float lots, float sl, float tp) =>
    direction = isLong ? "buy" : "sell"
    i_licenseID + "," + direction + "," + i_symbol + ",lot=" + str.tostring(lots, "#.##") + ",sl=" + str.tostring(sl, "#.##") + ",tp=" + str.tostring(tp, "#.##")

buildBrokerCloseAlert(bool isLong) =>
    cmd = isLong ? "closelong" : "closeshort"
    i_licenseID + "," + cmd + "," + i_symbol

buildBrokerPartialAlert(bool isLong, float lotsToClose) =>
    cmd = isLong ? "closelongvol" : "closeshortvol"
    i_licenseID + "," + cmd + "," + i_symbol + ",vol=" + str.tostring(lotsToClose, "#.##")

buildBrokerSLUpdateAlert(bool isLong, float newSL) =>
    cmd = isLong ? "newsltplong" : "newsltpshort"
    i_licenseID + "," + cmd + "," + i_symbol + ",sl=" + str.tostring(newSL, "#.##")

// --- Generate Alerts ---

// Entry Alerts
if longCondition
    reason = bullishBOS ? "Bullish BOS" : bullishCHoCH ? "Bullish CHoCH" : "OTE Entry"

    if i_enableAIAlerts
        aiAlert = buildAIAlert("ENTRY", "LONG", signalEntry, signalSL, signalTP1, signalTP2, signalLots, signalConfluence, signalTierString, currentTradeID, reason)
        alert(aiAlert, alert.freq_once_per_bar)

    if i_enableBrokerAlerts and str.length(i_licenseID) > 0
        brokerAlert = buildBrokerEntryAlert(true, signalLots, signalSL, signalTP1)
        alert(brokerAlert, alert.freq_once_per_bar)

if shortCondition
    reason = bearishBOS ? "Bearish BOS" : bearishCHoCH ? "Bearish CHoCH" : "OTE Entry"

    if i_enableAIAlerts
        aiAlert = buildAIAlert("ENTRY", "SHORT", signalEntry, signalSL, signalTP1, signalTP2, signalLots, signalConfluence, signalTierString, currentTradeID, reason)
        alert(aiAlert, alert.freq_once_per_bar)

    if i_enableBrokerAlerts and str.length(i_licenseID) > 0
        brokerAlert = buildBrokerEntryAlert(false, signalLots, signalSL, signalTP1)
        alert(brokerAlert, alert.freq_once_per_bar)

// TP1 Hit Alerts
var bool tp1AlertSent = false
if inPosition and tp1Hit and not tp1Hit[1]
    if i_enableAIAlerts
        aiAlert = buildAIAlert("TP1_HIT", inLongPosition ? "LONG" : "SHORT", signalEntry, trailingSL, signalTP1, signalTP2, signalLots * (1 - i_tp1ClosePercent/100), signalConfluence, signalTierString, currentTradeID, "TP1 reached - moved to breakeven")
        alert(aiAlert, alert.freq_once_per_bar)

    if i_enableBrokerAlerts and str.length(i_licenseID) > 0
        partialLots = signalLots * (i_tp1ClosePercent / 100)
        alert(buildBrokerPartialAlert(inLongPosition, partialLots), alert.freq_once_per_bar)
        alert(buildBrokerSLUpdateAlert(inLongPosition, trailingSL), alert.freq_once_per_bar)

    tp1AlertSent := true

// Trailing SL Update Alerts
var float lastAlertedSL = na
if inPosition and tp1Hit and not na(trailingSL) and trailingSL != lastAlertedSL
    if i_enableAIAlerts
        aiAlert = buildAIAlert("SL_UPDATE", inLongPosition ? "LONG" : "SHORT", signalEntry, trailingSL, signalTP1, signalTP2, signalLots * (1 - i_tp1ClosePercent/100), signalConfluence, signalTierString, currentTradeID, "Trailing stop updated")
        alert(aiAlert, alert.freq_once_per_bar)

    if i_enableBrokerAlerts and str.length(i_licenseID) > 0
        alert(buildBrokerSLUpdateAlert(inLongPosition, trailingSL), alert.freq_once_per_bar)

    lastAlertedSL := trailingSL

// Position Close Alerts
if not inPosition and inPosition[1]
    wasLong        = strategy.position_size[1] > 0
    lastTradeIndex = strategy.closedtrades - 1

    // v6: Handle trimmed trades with first_index
    float lastProfit = 0.0
    if lastTradeIndex >= strategy.closedtrades.first_index
        lastProfit := strategy.closedtrades.profit(lastTradeIndex)

    closeReason = lastProfit >= 0 ? "Take profit" : "Stop loss"

    if i_enableAIAlerts
        aiAlert = buildAIAlert("EXIT", wasLong ? "LONG" : "SHORT", signalEntry, signalSL, signalTP1, signalTP2, signalLots, signalConfluence, signalTierString, currentTradeID, closeReason)
        alert(aiAlert, alert.freq_once_per_bar)

    if i_enableBrokerAlerts and str.length(i_licenseID) > 0
        alert(buildBrokerCloseAlert(wasLong), alert.freq_once_per_bar)

    // Reset alert tracking
    tp1AlertSent  := false
    lastAlertedSL := na

// ============================================================================
// SECTION 16: VISUAL OUTPUT
// ============================================================================

// --- Clear and Redraw Visuals ---
if barstate.islast
    clearVisualArrays()

    // --- Draw Order Blocks ---
    if i_showOB and array.size(orderBlocks) > 0
        for ob in orderBlocks
            if not ob.isMitigated
                obAge = bar_index - ob.startBar
                if obAge <= i_obMaxAge
                    boxColor    = ob.isBullish ? color.new(color.blue, 80) : color.new(color.red, 80)
                    borderColor = ob.isBullish ? color.blue : color.red
                    newBox = box.new(ob.startBar, ob.top, bar_index + 10, ob.bottom,
                         bgcolor      = boxColor,
                         border_color = borderColor,
                         border_width = 1)
                    array.push(obBoxes, newBox)

    // --- Draw FVGs ---
    if i_showFVG and array.size(fvgList) > 0
        for fvg in fvgList
            if not fvg.isFilled
                fvgAge = bar_index - fvg.formationBar
                if fvgAge <= i_fvgMaxAge
                    boxColor = fvg.isBullish ? color.new(color.green, 85) : color.new(color.orange, 85)
                    newBox = box.new(fvg.formationBar, fvg.top, bar_index + 10, fvg.bottom,
                         bgcolor      = boxColor,
                         border_color = color.new(color.gray, 50),
                         border_width = 1)
                    array.push(fvgBoxes, newBox)

    // --- Draw Liquidity Levels ---
    if i_showLiquidity and array.size(liquidityLevels) > 0
        for level in liquidityLevels
            if level.touchCount >= 2 and not level.isSwept
                levelAge = bar_index - level.lastBar
                if levelAge <= 200
                    lineColor = level.isBuyside ? color.new(color.red, 30) : color.new(color.green, 30)
                    // v6: Using new linestyle parameter
                    newLine = line.new(level.firstBar, level.price, bar_index + 10, level.price,
                         color = lineColor,
                         style = line.style_dashed,
                         width = 1)
                    array.push(liqLines, newLine)

    // --- Draw SL/TP Lines ---
    if i_showSLTP and inPosition
        currentSL = tp1Hit and not na(trailingSL) ? trailingSL : signalSL
        slColor   = tp1Hit ? color.blue : color.red

        // v6: Using dotted style for trailing SL
        slStyle = tp1Hit ? line.style_dotted : line.style_solid
        slLine = line.new(bar_index - 10, currentSL, bar_index + 5, currentSL,
             color = slColor,
             style = slStyle,
             width = 2)
        array.push(slTPLines, slLine)

        if not tp1Hit
            tp1Line = line.new(bar_index - 10, signalTP1, bar_index + 5, signalTP1,
                 color = color.green,
                 style = line.style_solid,
                 width = 2)
            array.push(slTPLines, tp1Line)

        tp2Line = line.new(bar_index - 10, signalTP2, bar_index + 5, signalTP2,
             color = color.lime,
             style = line.style_dashed,
             width = 1)
        array.push(slTPLines, tp2Line)

// --- Entry Signal Markers ---
plotshape(i_showSignals and longCondition, title = "Long Signal",
     style    = shape.triangleup,
     location = location.belowbar,
     color    = color.green,
     size     = size.normal,
     text     = "LONG")

plotshape(i_showSignals and shortCondition, title = "Short Signal",
     style    = shape.triangledown,
     location = location.abovebar,
     color    = color.red,
     size     = size.normal,
     text     = "SHORT")

// --- Info Table (v6: Using text formatting) ---
if i_showTable
    var table infoTable = table.new(position.top_right, 2, 12,
         bgcolor      = color.new(color.black, 80),
         border_width = 1)

    if barstate.islast
        // Header with bold text (v6 feature)
        table.cell(infoTable, 0, 0, "SMC Strategy v6",
             text_color      = color.white,
             text_size       = size.small,
             text_formatting = text.format_bold)
        table.cell(infoTable, 1, 0, i_symbol,
             text_color      = color.yellow,
             text_size       = size.small,
             text_formatting = text.format_bold)

        // HTF Bias
        biasText  = htfBias == DIR_LONG ? "BULLISH" : htfBias == DIR_SHORT ? "BEARISH" : "NEUTRAL"
        biasColor = htfBias == DIR_LONG ? color.green : htfBias == DIR_SHORT ? color.red : color.gray
        table.cell(infoTable, 0, 1, "HTF Bias", text_color = color.white, text_size = size.tiny)
        table.cell(infoTable, 1, 1, biasText, text_color = biasColor, text_size = size.tiny)

        // Confluence Score
        currentConfluence = htfBias == DIR_LONG ? bullishConfluence : htfBias == DIR_SHORT ? bearishConfluence : bullishConfluence
        scoreColor = currentConfluence.total >= 90 ? color.green : currentConfluence.total >= 70 ? color.yellow : color.red
        table.cell(infoTable, 0, 2, "Confluence", text_color = color.white, text_size = size.tiny)
        table.cell(infoTable, 1, 2, str.tostring(currentConfluence.total, "#.#") + "/100", text_color = scoreColor, text_size = size.tiny)

        // Tier
        tierColor = currentConfluence.tier == TIER_APLUS ? color.green : currentConfluence.tier == TIER_A ? color.lime : currentConfluence.tier == TIER_B ? color.yellow : color.red
        table.cell(infoTable, 0, 3, "Tier", text_color = color.white, text_size = size.tiny)
        table.cell(infoTable, 1, 3, currentConfluence.tierString, text_color = tierColor, text_size = size.tiny, text_formatting = text.format_bold)

        // Session
        sessionText  = inLondonNYOverlap ? "OVERLAP" : inNYSession ? "NY" : inLondonSession ? "LONDON" : "OFF"
        sessionColor = inLondonNYOverlap ? color.green : (inNYSession or inLondonSession) ? color.yellow : color.red
        table.cell(infoTable, 0, 4, "Session", text_color = color.white, text_size = size.tiny)
        table.cell(infoTable, 1, 4, sessionText, text_color = sessionColor, text_size = size.tiny)

        // Trading Status
        statusText  = not tradingEnabled ? "DISABLED" : inCooldown ? "COOLDOWN" : not allFiltersPassed ? "FILTERED" : "ACTIVE"
        statusColor = statusText == "ACTIVE" ? color.green : color.red
        table.cell(infoTable, 0, 5, "Status", text_color = color.white, text_size = size.tiny)
        table.cell(infoTable, 1, 5, statusText, text_color = statusColor, text_size = size.tiny)

        // Daily Stats
        table.cell(infoTable, 0, 6, "Trades Today", text_color = color.white, text_size = size.tiny)
        table.cell(infoTable, 1, 6, str.tostring(dailyTrades) + "/" + str.tostring(i_maxDailyTrades), text_color = color.white, text_size = size.tiny)

        lossColor = dailyLosses >= i_maxDailyLosses ? color.red : dailyLosses > 0 ? color.orange : color.green
        table.cell(infoTable, 0, 7, "Losses Today", text_color = color.white, text_size = size.tiny)
        table.cell(infoTable, 1, 7, str.tostring(dailyLosses) + "/" + str.tostring(i_maxDailyLosses), text_color = lossColor, text_size = size.tiny)

        // Position
        posText  = inLongPosition ? "LONG" : inShortPosition ? "SHORT" : "FLAT"
        posColor = inLongPosition ? color.green : inShortPosition ? color.red : color.gray
        table.cell(infoTable, 0, 8, "Position", text_color = color.white, text_size = size.tiny)
        table.cell(infoTable, 1, 8, posText, text_color = posColor, text_size = size.tiny, text_formatting = text.format_bold)

        // TP1 Status
        tp1Text  = inPosition ? (tp1Hit ? "HIT - TRAILING" : "PENDING") : "-"
        tp1Color = tp1Hit ? color.green : inPosition ? color.yellow : color.gray
        table.cell(infoTable, 0, 9, "TP1", text_color = color.white, text_size = size.tiny)
        table.cell(infoTable, 1, 9, tp1Text, text_color = tp1Color, text_size = size.tiny)

        // Drawdown
        ddColor = currentDrawdown >= i_maxDrawdownPercent ? color.red : currentDrawdown >= 5 ? color.orange : color.green
        table.cell(infoTable, 0, 10, "Drawdown", text_color = color.white, text_size = size.tiny)
        table.cell(infoTable, 1, 10, str.tostring(currentDrawdown, "#.#") + "%", text_color = ddColor, text_size = size.tiny)

        // Zone
        pdText  = isPremium ? "PREMIUM" : isDiscount ? "DISCOUNT" : "EQUILIBRIUM"
        pdColor = isPremium ? color.red : isDiscount ? color.green : color.gray
        table.cell(infoTable, 0, 11, "Zone", text_color = color.white, text_size = size.tiny)
        table.cell(infoTable, 1, 11, pdText, text_color = pdColor, text_size = size.tiny)

// ============================================================================
// SECTION 17: STRATEGY PERFORMANCE PLOTS
// ============================================================================

// Plot key values for analysis (v6: improved data window display)
plot(bullishConfluence.total, title = "Bullish Confluence", display = display.data_window, color = color.green)
plot(bearishConfluence.total, title = "Bearish Confluence", display = display.data_window, color = color.red)
plot(float(htfBias), title = "HTF Bias", display = display.data_window, color = color.blue)
plot(float(structureBias), title = "Structure Bias", display = display.data_window, color = color.purple)
plot(atrRatio, title = "ATR Ratio", display = display.data_window, color = color.orange)
plot(currentDrawdown, title = "Drawdown %", display = display.data_window, color = color.red)
plot(inPosition ? (tp1Hit ? 2.0 : 1.0) : 0.0, title = "Position State", display = display.data_window, color = color.white)

// ============================================================================
// SECTION 18: STANDARD ALERT CONDITIONS
// ============================================================================

alertcondition(longCondition, title = "Long Entry Signal",
     message = "XAUUSD LONG Entry - Check AI alert for details")

alertcondition(shortCondition, title = "Short Entry Signal",
     message = "XAUUSD SHORT Entry - Check AI alert for details")

alertcondition(inPosition and tp1Hit and not tp1Hit[1], title = "TP1 Hit",
     message = "TP1 Hit - Partial close and move to breakeven")

alertcondition(dailyLosses >= i_maxDailyLosses, title = "Daily Loss Limit",
     message = "Daily loss limit reached - Trading disabled")

alertcondition(currentDrawdown >= i_maxDrawdownPercent, title = "Max Drawdown",
     message = "Maximum drawdown reached - Trading disabled")

alertcondition(not inPosition and inPosition[1], title = "Position Closed",
     message = "Position closed")

// ============================================================================
// END OF STRATEGY - Pine Script v6
// ============================================================================
